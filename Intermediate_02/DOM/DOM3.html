<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOM Part 3</title>
</head>
<body style="background-color: #212121; color: #fff; font-family: Arial, sans-serif; text-align: center; padding: 20px;">
    <ul class="language">
        <li>JavaScript</li>
    </ul>
    <script>
        // Add another list item to the ul with class language
        function addLanguage(langName){
            const li = document.createElement('li');
            li.innerHTML = `${langName}`;
            document.querySelector('.language').appendChild(li);
            // Problem in this method is everytime we need to traverse the tree to add a child node.
        }
        addLanguage('Python');

        function addOptimisedLanguage(langName){
            const li = document.createElement('li');
            li.appendChild(document.createTextNode(langName));
            document.querySelector('.language').appendChild(li);
            // This method is more optimised as we are not removing the childs of the element and then adding text node, instead we create one and add directly
            // innerText is slower than textContent since innerText need to compute what is visible while textContent retrieves all text node not caring about its CSS whether display is none or visibility is hidden
        }
        addOptimisedLanguage('Java');

        // TRUE OPTIMISATION, AVOIDS REPEATED TREE TRAVERSAL
        const ul = document.querySelector('.language');
        function mostAddOptimisedLanguage(langName){
            const li = document.createElement('li');
            li.appendChild(document.createTextNode(langName));
            ul.appendChild(li);   // ‚úÖ no repeated DOM traversal
        }


        
        // EDIT
        document.querySelector('li:nth-child(2)').innerHTML = 'Java (Edited)'; // Edit the second list item
        //OR
        const newli = document.createElement('li');
        newli.innerHTML = 'Java (Edited using new element)'; // Create a new list item with the same content
        //document.querySelector('.language').replaceChild(newli, document.querySelector('li:nth-child(2)')); // Replace the second list item with the new one
        document.querySelector('li:nth-child(2)').replaceWith(newli); // Replace the second list item with the new one
        //OR
        //document.querySelector(li:first-child).outerHTML = "<li>Edited using outerHTML, which is not recommended</li>"; // Replace the first list item with the new one using outerHTML
        // REMOVE
        document.querySelector('li:last-child').remove(); // Remove the last list item
        // 1. How :nth-child(n) works
        // It looks at the position of the element among ALL its siblings (not just same tags).
        // Then it checks if the element at that position also matches the given selector (li in your case).
        // üîπ 2. How :nth-of-type(n) works
        // It only looks at siblings of the same tag type.
        // Then applies the counting on them.
        /* ‚û°Ô∏è The browser doesn‚Äôt need you to explicitly write the parent.
                Instead, it goes like this:
                
                Start scanning the DOM from the top.
                
                Every time it encounters an <li>, it asks:
                
                "Are you the 2nd child of your parent?"
                
                If yes ‚Üí that <li> matches.
                
                Stop at the first match (because it‚Äôs querySelector, not querySelectorAll).
                
                So the ‚Äúparent‚Äù is implicitly the parent of the <li> being tested.
                You don‚Äôt provide the parent manually ‚Äî CSS selectors are evaluated relative to each candidate element and its parent.

*/
    </script>
</body>
</html>
